# 王道考研机试笔记

[TOC]

## 1. 暴力求解

### 1.1 枚举

首先观察/计算枚举量，是否在允许枚举的范围内。如果需要的计算次数在几万以内，可以尝试枚举求解。

尽量减少枚举量，方法有：通过数学化简减少枚举量、避免不必要的枚举等。

可以配合贪心等策略，例如当如果有多个可行解的情况下取最大的可行解，则枚举可以按从大到小的方向枚举，这样只要枚举到第一个可行解即可。

### 1.2 模拟
所谓模拟，就是不涉及特别深的知识，只需要用程序实现题目的要求。
#### 1.2.1 图形排版

有两类图形排版问题：
- 第一类：可以直接把图形排版规律转换成输出规律（从上到下、从左到右），在输出语句中表达出来，这类是比较简单的。

- 第二类：比较难把图形规律转换成包含图形规律规律的输出语句，也就是很难一边输出一边计算图形规律，或者说这么做是比较复杂的。在这种情况下，可以先内存中构造，构造好之后再输出。

    有时，在内存中构造图形时需要用到DFS/递归/循环的方式。

#### 1.2.2 日期问题

#### 1.2.3 其他模拟

## 2. 排序与查找

### 2.1 排序

sort函数的使用，默认是升序

实现对结构体、类的自定义排序有两种方式：

1. 设计比较函数
2. 在结构体、类的内部重载小于号

### 2.2 查找

查找可能需要预排序，比如二分查找

查找方式：

1. 线性查找，当查找次数少时有性能优势

2. 二分查找，预排序需要开销，当查找次数多时体现出性能优势

    STL函数：

    binary_search, lower_bound, upper_bound

    如果手动实现的话，迭代版本比较好写

    有时计算 `int middle = (left+right)/2` 会溢出，可以写成 `int middle = left+(right-left)/2`

3. 其他：还可以用map、unordered_map进行查找，尤其是本身无法排序的数据，根本用不了二分查找

## 3. 字符串

> 见 string.md

3.1 字符串

3.2 字符串处理

3.3 字符串匹配

## 4. 数据结构一

向量vector

队列queue

栈stack

## 5. 数学问题

进制转换

最大公约数与最小公倍数

质数（素数）

分解质因数

快速幂

矩阵与矩阵快速幂

高精度整数

## 6. 贪心策略

简单贪心

区间贪心

## 7. 递归与分治

> 递归法和分治思想往往同时出现

递归策略

分治法

## 8. 搜索

广度优先搜索

深度优先搜索

## 9. 数据结构二

二叉树

- 结构定义
- 遍历

二叉排序树（二叉搜索树）

优先队列 priority_queue

- 顺序问题
- 哈弗曼树（小顶堆的写法）

映射 map（红黑树实现，查找效率$O(logn)$）

无序映射 unordered_map（散列表实现，查找效率$O(1)$）

## 10. 图论

概述

- 邻接矩阵

- 邻接表

并查集

最小生成树

- Kruskal算法（代码简单，效率高）
- Prim算法

最短路径（Dijkstra算法）

拓扑排序

关键路径

## 11. 动态规划

递推求解

最大连续子序列和

最长递增子序列

最长公共子序列

背包问题

- 0-1背包
- 完全背包
- 多重背包

其他问题

